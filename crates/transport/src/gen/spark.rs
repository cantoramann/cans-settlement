// This file is @generated by prost-build.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubscribeToEventsRequest {
    #[prost(bytes = "bytes", tag = "10")]
    pub identity_public_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeToEventsResponse {
    #[prost(oneof = "subscribe_to_events_response::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<subscribe_to_events_response::Event>,
}
/// Nested message and enum types in `SubscribeToEventsResponse`.
pub mod subscribe_to_events_response {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Transfer(super::TransferEvent),
        #[prost(message, tag = "2")]
        Deposit(super::DepositEvent),
        #[prost(message, tag = "3")]
        Connected(super::ConnectedEvent),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectedEvent {}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferEvent {
    #[prost(message, optional, tag = "10")]
    pub transfer: ::core::option::Option<Transfer>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DepositEvent {
    #[prost(message, optional, tag = "10")]
    pub deposit: ::core::option::Option<TreeNode>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PageRequest {
    #[prost(int32, tag = "1")]
    pub unsafe_page_size: i32,
    #[prost(uint32, tag = "4")]
    pub page_size: u32,
    #[prost(string, tag = "2")]
    pub cursor: ::prost::alloc::string::String,
    #[prost(enumeration = "Direction", tag = "3")]
    pub direction: i32,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PageResponse {
    #[prost(bool, tag = "1")]
    pub has_next_page: bool,
    #[prost(bool, tag = "2")]
    pub has_previous_page: bool,
    #[prost(string, tag = "3")]
    pub next_cursor: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub previous_cursor: ::prost::alloc::string::String,
}
/// *
/// DepositAddressProof is the proof of possession of the deposit address.
/// When a user wants to generate a deposit address, they are sending their
/// public key to the SE, and the SE will respond with an address of user's
/// public key + SE's public key.
///
/// In the trusty deposit flow, user will need to know that this address is
/// valid, and no single SE can generate this address.
///
/// The SE will need to sign the address with their identity keys, and have a
/// proof of possession of the signing key piece that the SE holds.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DepositAddressProof {
    /// The signatures of the address by the SE's identity keys.
    #[prost(map = "string, bytes", tag = "1")]
    pub address_signatures: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::bytes::Bytes,
    >,
    /// The proof of possession of the signing key piece by the SE.
    #[prost(bytes = "bytes", tag = "2")]
    pub proof_of_possession_signature: ::prost::bytes::Bytes,
}
/// *
/// GenerateDepositAddressRequest is the request to generate a deposit address.
/// The user will send their public key to the SE, and the SE will respond with
/// an address of user's public key + SE's public key.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateDepositAddressRequest {
    /// The signing public key of the user.
    #[prost(bytes = "bytes", tag = "1")]
    pub signing_public_key: ::prost::bytes::Bytes,
    /// The identity public key of the user.
    #[prost(bytes = "bytes", tag = "2")]
    pub identity_public_key: ::prost::bytes::Bytes,
    /// The network of the bitcoin network.
    #[prost(enumeration = "Network", tag = "3")]
    pub network: i32,
    /// The UUID to use for the created TreeNode
    #[prost(string, optional, tag = "4")]
    pub leaf_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Generate static deposit address
    #[prost(bool, optional, tag = "5")]
    pub is_static: ::core::option::Option<bool>,
}
/// *
/// Address is the address of the user's public key + SE's public key.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    /// The p2tr address of the user's public key + SE's public key.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// The verifying key of the address, which is user's public key + SE's public
    /// key.
    #[prost(bytes = "bytes", tag = "2")]
    pub verifying_key: ::prost::bytes::Bytes,
    /// The proof of possession of the address by the SE.
    #[prost(message, optional, tag = "3")]
    pub deposit_address_proof: ::core::option::Option<DepositAddressProof>,
    /// Is it a static deposit address
    #[prost(bool, tag = "5")]
    pub is_static: bool,
}
/// *
/// GenerateDepositAddressResponse is the response to the request to generate a
/// deposit address.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateDepositAddressResponse {
    #[prost(message, optional, tag = "1")]
    pub deposit_address: ::core::option::Option<Address>,
}
/// *
/// GenerateStaticDepositAddressRequest is the request to generate a static
/// deposit address.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateStaticDepositAddressRequest {
    /// The signing public key of the user.
    #[prost(bytes = "bytes", tag = "1")]
    pub signing_public_key: ::prost::bytes::Bytes,
    /// The identity public key of the user.
    #[prost(bytes = "bytes", tag = "2")]
    pub identity_public_key: ::prost::bytes::Bytes,
    /// The network of the bitcoin network.
    #[prost(enumeration = "Network", tag = "3")]
    pub network: i32,
}
/// *
/// GenerateStaticDepositAddressResponse is the response to the request to
/// generate a static deposit address.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateStaticDepositAddressResponse {
    #[prost(message, optional, tag = "1")]
    pub deposit_address: ::core::option::Option<Address>,
}
/// *
/// Request to rotate a static deposit address.
/// This archives the current default address and generates a new one.
/// Old address still can be used to receive deposits.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RotateStaticDepositAddressRequest {
    /// The signing public key of the user to aggregate with SO keys and produce
    /// the final pubkey used to generate P2TR address.
    #[prost(bytes = "bytes", tag = "1")]
    pub signing_public_key: ::prost::bytes::Bytes,
    /// The network of the bitcoin network.
    #[prost(enumeration = "Network", tag = "2")]
    pub network: i32,
}
/// *
/// Response to the request to rotate a static deposit address.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RotateStaticDepositAddressResponse {
    /// The newly generated default deposit address.
    #[prost(message, optional, tag = "1")]
    pub new_deposit_address: ::core::option::Option<Address>,
    /// The archived (previous default) deposit address.
    #[prost(message, optional, tag = "2")]
    pub archived_deposit_address: ::core::option::Option<Address>,
}
/// *
/// UTXO represents a utxo on the bitcoin network.
/// The UTXO is used to create a tree on Spark, it can also be an off-chain utxo
/// so that the user can create the tree first and the broadcast the transaction.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Utxo {
    /// The raw transaction of the utxo (optional).
    #[prost(bytes = "bytes", tag = "1")]
    pub raw_tx: ::prost::bytes::Bytes,
    /// The vout of the raw transaction for the utxo, which will be used to create
    /// the tree. Required.
    #[prost(uint32, tag = "2")]
    pub vout: u32,
    /// The network of the bitcoin network. Required.
    #[prost(enumeration = "Network", tag = "3")]
    pub network: i32,
    /// Transaction Id string, produced from transaction hash by reversing the
    /// bytes, converted to bytes. Required, but older code may not provide it.
    #[prost(bytes = "bytes", tag = "4")]
    pub txid: ::prost::bytes::Bytes,
}
/// *
/// NodeOutput represents a node on the tree.
/// This is similar to a UTXO, which is used to create a subtree on Spark. But
/// instead of using a utxo, a existing node on the tree is used as the utxo.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeOutput {
    /// The id of the node.
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    /// The vout of the raw transaction for the node, which will be used to create
    /// the tree.
    #[prost(uint32, tag = "2")]
    pub vout: u32,
}
/// *
/// SigningJob is the job for signing a transaction.
/// The signing job is used to sign a bitcoin transaction using Spark FROST.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SigningJob {
    /// The signing public key of the user.
    #[prost(bytes = "bytes", tag = "1")]
    pub signing_public_key: ::prost::bytes::Bytes,
    /// The unsigned raw transaction to be signed.
    #[prost(bytes = "bytes", tag = "2")]
    pub raw_tx: ::prost::bytes::Bytes,
    /// The signing nonce commitment of the user.
    #[prost(message, optional, tag = "3")]
    pub signing_nonce_commitment: ::core::option::Option<
        super::common::SigningCommitment,
    >,
}
/// *
/// SigningKeyshare is the keyshare information of the SE keyshare group.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigningKeyshare {
    /// The identifiers of the owners of the keyshare.
    #[prost(string, repeated, tag = "1")]
    pub owner_identifiers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The threshold of the keyshare.
    #[prost(uint32, tag = "2")]
    pub threshold: u32,
    /// The public key of the keyshare.
    #[prost(bytes = "bytes", tag = "3")]
    pub public_key: ::prost::bytes::Bytes,
    /// The public shares of the keyshare.
    #[prost(map = "string, bytes", tag = "4")]
    pub public_shares: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::bytes::Bytes,
    >,
    /// The latest update time of the keyshare.
    #[prost(message, optional, tag = "5")]
    pub updated_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// *
/// SigningResult is the result of the signing job from the SE keyshare group.
/// It contains all the information for user to sign their part. After user
/// signs, the signature can be aggregated to form the final signature.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigningResult {
    /// The public keys of the SE keyshare group.
    #[prost(map = "string, bytes", tag = "1")]
    pub public_keys: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::bytes::Bytes,
    >,
    /// The signing nonce commitments of the SE keyshare group.
    #[prost(map = "string, message", tag = "2")]
    pub signing_nonce_commitments: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::common::SigningCommitment,
    >,
    /// The signature shares of the SE keyshare group.
    #[prost(map = "string, bytes", tag = "3")]
    pub signature_shares: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::bytes::Bytes,
    >,
    /// The keyshare information of the SE keyshare group.
    #[prost(message, optional, tag = "4")]
    pub signing_keyshare: ::core::option::Option<SigningKeyshare>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenewLeafRequest {
    #[prost(string, tag = "1")]
    pub leaf_id: ::prost::alloc::string::String,
    #[prost(oneof = "renew_leaf_request::SigningJobs", tags = "2, 3, 4")]
    pub signing_jobs: ::core::option::Option<renew_leaf_request::SigningJobs>,
}
/// Nested message and enum types in `RenewLeafRequest`.
pub mod renew_leaf_request {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SigningJobs {
        /// Resets the node transaction timelock and refund transaction timelock
        /// for a leaf to 2000. The old node transaction is invalidated by
        /// introducing a "split node" with zero timelock that spends to a new
        /// node transaction. Takes in the signing jobs for the updated
        /// node, refund, and split node transactions with the new timelocks.
        /// Requires that the existing node transaction timelock is <= 300
        /// at the time this function is called. Returns an error if these
        /// conditions are not met.
        #[prost(message, tag = "2")]
        RenewNodeTimelockSigningJob(super::RenewNodeTimelockSigningJob),
        /// Resets the refund transaction timelock for a leaf to 2000. Takes in
        /// the signing jobs for the updated transactions with the new timelocks.
        /// Requires that the existing refund transaction timelock is <= 300 and
        /// the node transaction timelock > 300 at the time this function is
        /// called. Returns an error if these conditions are not met.
        #[prost(message, tag = "3")]
        RenewRefundTimelockSigningJob(super::RenewRefundTimelockSigningJob),
        /// A special case of refresh for when the node transaction is at 0 and
        /// cannot be decremented further. This operation resets the refund
        /// transaction's timelock and, similar to renew node, adds an additional
        /// node transaction to the transaction chain with zero timelock as well.
        /// This case is mostly used for user-created trees from L1 deposits.
        #[prost(message, tag = "4")]
        RenewNodeZeroTimelockSigningJob(super::RenewNodeZeroTimelockSigningJob),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenewNodeTimelockSigningJob {
    /// Signing job with the new "split node" transaction. This spends the
    /// inputs of the old node transaction and its outputs are spent by the new
    /// node transaction. Timelock of split node transaction must be 0.
    #[prost(message, optional, tag = "1")]
    pub split_node_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "2")]
    pub split_node_direct_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    /// Signing job with the updated node transaction. The updated transaction is
    /// expected to have a timelock of 2000.
    #[prost(message, optional, tag = "3")]
    pub node_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "4")]
    pub refund_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "5")]
    pub direct_node_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "6")]
    pub direct_refund_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "7")]
    pub direct_from_cpfp_refund_tx_signing_job: ::core::option::Option<
        UserSignedTxSigningJob,
    >,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenewRefundTimelockSigningJob {
    /// Signing job with the updated node transaction. The updated transaction is
    /// expected to have a timelock of 100 less than the existing node transaction.
    #[prost(message, optional, tag = "1")]
    pub node_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    /// Signing job with the updated refund transaction. This updated transaction
    /// must have a timelock of 2000.
    #[prost(message, optional, tag = "2")]
    pub refund_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "3")]
    pub direct_node_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "4")]
    pub direct_refund_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "5")]
    pub direct_from_cpfp_refund_tx_signing_job: ::core::option::Option<
        UserSignedTxSigningJob,
    >,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenewNodeZeroTimelockSigningJob {
    /// Signing job with the new node transaction. The updated transaction is
    /// expected to have a timelock of 0.
    #[prost(message, optional, tag = "1")]
    pub node_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    /// Signing job with the updated refund transaction. This updated transaction
    /// must have a timelock of 2000.
    #[prost(message, optional, tag = "2")]
    pub refund_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "3")]
    pub direct_node_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "5")]
    pub direct_from_cpfp_refund_tx_signing_job: ::core::option::Option<
        UserSignedTxSigningJob,
    >,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenewLeafResponse {
    #[prost(oneof = "renew_leaf_response::RenewResult", tags = "1, 2, 3")]
    pub renew_result: ::core::option::Option<renew_leaf_response::RenewResult>,
}
/// Nested message and enum types in `RenewLeafResponse`.
pub mod renew_leaf_response {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RenewResult {
        #[prost(message, tag = "1")]
        RenewNodeTimelockResult(super::RenewNodeTimelockResult),
        #[prost(message, tag = "2")]
        RenewRefundTimelockResult(super::RenewRefundTimelockResult),
        #[prost(message, tag = "3")]
        RenewNodeZeroTimelockResult(super::RenewNodeZeroTimelockResult),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenewNodeTimelockResult {
    #[prost(message, optional, tag = "1")]
    pub split_node: ::core::option::Option<TreeNode>,
    #[prost(message, optional, tag = "2")]
    pub node: ::core::option::Option<TreeNode>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenewRefundTimelockResult {
    #[prost(message, optional, tag = "1")]
    pub node: ::core::option::Option<TreeNode>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenewNodeZeroTimelockResult {
    #[prost(message, optional, tag = "1")]
    pub split_node: ::core::option::Option<TreeNode>,
    #[prost(message, optional, tag = "2")]
    pub node: ::core::option::Option<TreeNode>,
}
/// *
/// NodeSignatureShares is the signature shares for a node on the tree.
/// For each tree node, the verifying key stays the same for both transactions.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeSignatureShares {
    /// The id of the node.
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    /// The signing result of the node's transaction. This transaction is to pay to
    /// self.
    #[prost(message, optional, tag = "2")]
    pub node_tx_signing_result: ::core::option::Option<SigningResult>,
    /// The signing result of the node's refund transaction. This transaction is to
    /// pay to the user.
    #[prost(message, optional, tag = "3")]
    pub refund_tx_signing_result: ::core::option::Option<SigningResult>,
    /// The verifying key of the node.
    #[prost(bytes = "bytes", tag = "4")]
    pub verifying_key: ::prost::bytes::Bytes,
    /// The signing result of the node's transaction. This transaction is to pay to
    /// self.
    #[deprecated]
    #[prost(message, optional, tag = "5")]
    pub direct_node_tx_signing_result: ::core::option::Option<SigningResult>,
    /// The signing result of the node's direct refund transaction. This
    /// transaction is to broadcast for the SO.
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub direct_refund_tx_signing_result: ::core::option::Option<SigningResult>,
    /// The signing result of the node's direct from cpfp refund transaction. This
    /// transaction is to broadcast for the SO.
    #[prost(message, optional, tag = "7")]
    pub direct_from_cpfp_refund_tx_signing_result: ::core::option::Option<SigningResult>,
}
/// *
/// NodeSignatures is the final signatures for a node on the tree.
/// It contains the signature for the node's transaction and refund transaction.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeSignatures {
    /// The id of the node.
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    /// The final signature of the node's cpfp transaction. This transaction is to
    /// pay to self.
    #[prost(bytes = "bytes", tag = "2")]
    pub node_tx_signature: ::prost::bytes::Bytes,
    /// The final signature of the node's cpfp refund transaction. This transaction
    /// is to pay to the user.
    #[prost(bytes = "bytes", tag = "3")]
    pub refund_tx_signature: ::prost::bytes::Bytes,
    /// The final signature of the node's direct transaction. This transaction is
    /// to pay for the watchtower.
    #[prost(bytes = "bytes", tag = "4")]
    pub direct_node_tx_signature: ::prost::bytes::Bytes,
    /// The final signature of the node's direct refund transaction. This
    /// transaction is to pay for the watchtower.
    #[prost(bytes = "bytes", tag = "5")]
    pub direct_refund_tx_signature: ::prost::bytes::Bytes,
    /// The final signature of the node's direct from cpfp refund transaction. This
    /// transaction is to pay for the watchtower.
    #[prost(bytes = "bytes", tag = "6")]
    pub direct_from_cpfp_refund_tx_signature: ::prost::bytes::Bytes,
}
/// *
/// StartTreeCreationRequest is the request to start the tree creation for a tree
/// root node.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StartTreeCreationRequest {
    /// The identity public key of the user.
    #[prost(bytes = "bytes", tag = "1")]
    pub identity_public_key: ::prost::bytes::Bytes,
    /// The on-chain utxo to be used to be spent by the root node.
    #[prost(message, optional, tag = "2")]
    pub on_chain_utxo: ::core::option::Option<Utxo>,
    /// The signing job for the root node's cpfp transaction.
    #[prost(message, optional, tag = "3")]
    pub root_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The signing job for the root node's cpfp refund transaction.
    #[prost(message, optional, tag = "4")]
    pub refund_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The signing job for the root node's direct transaction.
    #[prost(message, optional, tag = "5")]
    pub direct_root_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The signing job for the root node's direct refund transaction
    #[prost(message, optional, tag = "6")]
    pub direct_refund_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The signing job for the root node's direct refund transaction
    #[prost(message, optional, tag = "7")]
    pub direct_from_cpfp_refund_tx_signing_job: ::core::option::Option<SigningJob>,
}
/// *
/// StartTreeCreationResponse is the response to the request to start the tree
/// creation for a tree root node.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartTreeCreationResponse {
    /// The id of the tree.
    #[prost(string, tag = "1")]
    pub tree_id: ::prost::alloc::string::String,
    /// The signature shares for the root node.
    #[prost(message, optional, tag = "2")]
    pub root_node_signature_shares: ::core::option::Option<NodeSignatureShares>,
}
/// *
/// StartDepositTreeCreationRequest is the request to start the tree creation for
/// a tree root node.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StartDepositTreeCreationRequest {
    /// The identity public key of the user.
    #[prost(bytes = "bytes", tag = "1")]
    pub identity_public_key: ::prost::bytes::Bytes,
    /// The on-chain utxo to be used to be spent by the root node.
    #[prost(message, optional, tag = "2")]
    pub on_chain_utxo: ::core::option::Option<Utxo>,
    /// The signing job for the root node's transaction.
    #[prost(message, optional, tag = "3")]
    pub root_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The signing job for the root node's refund transaction.
    #[prost(message, optional, tag = "4")]
    pub refund_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The direct signing job for the root node's transaction.
    #[deprecated]
    #[prost(message, optional, tag = "5")]
    pub direct_root_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The signing job for the root node's direct refund transaction.
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub direct_refund_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The signing job for the root node's direct from cpfp refund transaction.
    #[prost(message, optional, tag = "7")]
    pub direct_from_cpfp_refund_tx_signing_job: ::core::option::Option<SigningJob>,
}
/// *
/// StartDepositTreeCreationResponse is the response to the request to start the
/// tree creation for a tree root node.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartDepositTreeCreationResponse {
    /// The id of the tree.
    #[prost(string, tag = "1")]
    pub tree_id: ::prost::alloc::string::String,
    /// The signature shares for the root node.
    #[prost(message, optional, tag = "2")]
    pub root_node_signature_shares: ::core::option::Option<NodeSignatureShares>,
}
/// *
/// FinalizeDepositTreeCreationRequest is the request to finalize the tree
/// creation for a tree root node.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeDepositTreeCreationRequest {
    /// The identity public key of the user
    #[prost(bytes = "bytes", tag = "1")]
    pub identity_public_key: ::prost::bytes::Bytes,
    /// The on-chain utxo
    #[prost(message, optional, tag = "2")]
    pub on_chain_utxo: ::core::option::Option<Utxo>,
    /// User-signed transactions (with user signature shares, aggregated by server)
    #[prost(message, optional, tag = "3")]
    pub root_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "4")]
    pub refund_tx_signing_job: ::core::option::Option<UserSignedTxSigningJob>,
    #[prost(message, optional, tag = "5")]
    pub direct_from_cpfp_refund_tx_signing_job: ::core::option::Option<
        UserSignedTxSigningJob,
    >,
}
/// *
/// FinalizeDepositTreeCreationResponse is the response to the request to
/// finalize the tree creation for a tree root node.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeDepositTreeCreationResponse {
    /// the root node of the created tree
    #[prost(message, optional, tag = "1")]
    pub root_node: ::core::option::Option<TreeNode>,
}
/// *
/// TreeNode represents a node on the tree.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeNode {
    /// The id of the node.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The id of the tree for this node .
    #[prost(string, tag = "2")]
    pub tree_id: ::prost::alloc::string::String,
    /// The value that this node holds.
    #[prost(uint64, tag = "3")]
    pub value: u64,
    /// The id of the parent node.
    #[prost(string, optional, tag = "4")]
    pub parent_node_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The cpfp transaction of the node, this transaction is to pay to the same
    /// address as the node.
    #[prost(bytes = "bytes", tag = "5")]
    pub node_tx: ::prost::bytes::Bytes,
    /// The refund transaction of the node, this transaction is to pay to the user.
    #[prost(bytes = "bytes", tag = "6")]
    pub refund_tx: ::prost::bytes::Bytes,
    /// This vout is the vout to spend the previous transaction, which is in the
    /// parent node.
    #[prost(uint32, tag = "7")]
    pub vout: u32,
    /// The verifying public key of the node.
    #[prost(bytes = "bytes", tag = "8")]
    pub verifying_public_key: ::prost::bytes::Bytes,
    /// The identity public key of the owner of the node.
    #[prost(bytes = "bytes", tag = "9")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    /// The signing keyshare information of the node on the SE side.
    #[prost(message, optional, tag = "10")]
    pub signing_keyshare: ::core::option::Option<SigningKeyshare>,
    /// The status of the node.
    #[prost(string, tag = "11")]
    pub status: ::prost::alloc::string::String,
    /// The network of the node.
    #[prost(enumeration = "Network", tag = "12")]
    pub network: i32,
    /// The creation time of the node.
    #[prost(message, optional, tag = "13")]
    pub created_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The latest update time of the node.
    #[prost(message, optional, tag = "14")]
    pub updated_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The signing public key of the owner of the node.
    #[prost(bytes = "bytes", tag = "15")]
    pub owner_signing_public_key: ::prost::bytes::Bytes,
    /// The direct transaction of the node, this transaction is for the watchtower
    /// to broadcast.
    #[prost(bytes = "bytes", tag = "16")]
    pub direct_tx: ::prost::bytes::Bytes,
    /// The refund transaction of the node, this transaction is to pay to the user.
    #[prost(bytes = "bytes", tag = "17")]
    pub direct_refund_tx: ::prost::bytes::Bytes,
    /// The refund transaction of the node, this transaction is to pay to the user.
    #[prost(bytes = "bytes", tag = "18")]
    pub direct_from_cpfp_refund_tx: ::prost::bytes::Bytes,
}
/// *
/// FinalizeNodeSignaturesRequest is the request to finalize the signatures for a
/// node.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeNodeSignaturesRequest {
    /// The intent of the signature.
    #[prost(enumeration = "super::common::SignatureIntent", tag = "1")]
    pub intent: i32,
    /// The signatures for the node.
    #[prost(message, repeated, tag = "2")]
    pub node_signatures: ::prost::alloc::vec::Vec<NodeSignatures>,
}
/// *
/// FinalizeNodeSignaturesResponse is the response to the request to finalize the
/// signatures for a node.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeNodeSignaturesResponse {
    /// The nodes that are finalized.
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<TreeNode>,
}
/// *
/// SecretShare is a secret share of a secret, using Feldman VSS.
/// The secret share is in the field of secp256k1 scalar field.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SecretShare {
    /// The secret share.
    #[prost(bytes = "bytes", tag = "1")]
    pub secret_share: ::prost::bytes::Bytes,
    /// The proofs for the secret share. They are the compressed public keys in
    /// secp256k1 curve. proofs\[0\] is the public key of the secret, while
    /// proofs\[1..n\] are the public key of the polynomial.
    #[prost(bytes = "bytes", repeated, tag = "2")]
    pub proofs: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
/// *
/// SecretProof is the proof for a secret share using Feldman VSS.
/// The proof is the compressed public keys in secp256k1 curve.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SecretProof {
    /// The proofs for the secret share.
    /// proofs\[0\] is the public key of the secret, while proofs\[1..n\] are the
    /// public key of the polynomial.
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub proofs: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeafRefundTxSigningJob {
    #[prost(string, tag = "1")]
    pub leaf_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub refund_tx_signing_job: ::core::option::Option<SigningJob>,
    #[prost(message, optional, tag = "3")]
    pub direct_refund_tx_signing_job: ::core::option::Option<SigningJob>,
    #[prost(message, optional, tag = "4")]
    pub direct_from_cpfp_refund_tx_signing_job: ::core::option::Option<SigningJob>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSignedTxSigningJob {
    #[prost(string, tag = "1")]
    pub leaf_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub signing_public_key: ::prost::bytes::Bytes,
    /// CPFP Refund Tx that is created when the User signs refunds. It spends the
    /// node transaction to the receiver.
    #[prost(bytes = "bytes", tag = "3")]
    pub raw_tx: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "4")]
    pub signing_nonce_commitment: ::core::option::Option<
        super::common::SigningCommitment,
    >,
    #[prost(bytes = "bytes", tag = "5")]
    pub user_signature: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "6")]
    pub signing_commitments: ::core::option::Option<SigningCommitments>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeafRefundTxSigningResult {
    #[prost(string, tag = "1")]
    pub leaf_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub refund_tx_signing_result: ::core::option::Option<SigningResult>,
    #[prost(bytes = "bytes", tag = "3")]
    pub verifying_key: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "4")]
    pub direct_refund_tx_signing_result: ::core::option::Option<SigningResult>,
    #[prost(message, optional, tag = "5")]
    pub direct_from_cpfp_refund_tx_signing_result: ::core::option::Option<SigningResult>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartUserSignedTransferRequest {
    #[prost(string, tag = "1")]
    pub transfer_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, repeated, tag = "3")]
    pub leaves_to_send: ::prost::alloc::vec::Vec<UserSignedTxSigningJob>,
    #[prost(bytes = "bytes", tag = "4")]
    pub receiver_identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "5")]
    pub expiry_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "6")]
    pub direct_leaves_to_send: ::prost::alloc::vec::Vec<UserSignedTxSigningJob>,
    #[prost(message, repeated, tag = "7")]
    pub direct_from_cpfp_leaves_to_send: ::prost::alloc::vec::Vec<
        UserSignedTxSigningJob,
    >,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartTransferRequest {
    #[prost(string, tag = "1")]
    pub transfer_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    /// This field is used for swap and coop exits. Regular transfers must use
    /// the transfer_package field.
    #[prost(message, repeated, tag = "3")]
    pub leaves_to_send: ::prost::alloc::vec::Vec<LeafRefundTxSigningJob>,
    #[prost(bytes = "bytes", tag = "4")]
    pub receiver_identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "5")]
    pub expiry_time: ::core::option::Option<::prost_types::Timestamp>,
    /// This field is required for transfers of type "transfer". If this field
    /// is set, the leaves_to_send and key_tweak_proofs will be ignored.
    #[prost(message, optional, tag = "7")]
    pub transfer_package: ::core::option::Option<TransferPackage>,
    /// The invoice this transfer pays.
    #[prost(string, tag = "10")]
    pub spark_invoice: ::prost::alloc::string::String,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartTransferResponse {
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<Transfer>,
    #[prost(message, repeated, tag = "2")]
    pub signing_results: ::prost::alloc::vec::Vec<LeafRefundTxSigningResult>,
}
/// *
/// TransferPackage is a package of leaves to send and key tweaks to send.
/// This is in the improved send transfer flow where the sender can send the
/// transfer in one call to the coordinator SO.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferPackage {
    /// The leaves to send, with user signed cpfp refunds and signing package.
    #[prost(message, repeated, tag = "1")]
    pub leaves_to_send: ::prost::alloc::vec::Vec<UserSignedTxSigningJob>,
    /// The map of SO identifier to ciphertext of SendLeafTweaks.
    #[prost(map = "string, bytes", tag = "2")]
    pub key_tweak_package: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::bytes::Bytes,
    >,
    /// The signature of user to prove that the key_tweak_package is not tampered.
    #[prost(bytes = "bytes", tag = "3")]
    pub user_signature: ::prost::bytes::Bytes,
    /// The leaves to send, with user signed direct refunds and signing package.
    #[prost(message, repeated, tag = "4")]
    pub direct_leaves_to_send: ::prost::alloc::vec::Vec<UserSignedTxSigningJob>,
    /// The leaves to send, with user signed direct from cpfp refunds and signing
    /// package.
    #[prost(message, repeated, tag = "5")]
    pub direct_from_cpfp_leaves_to_send: ::prost::alloc::vec::Vec<
        UserSignedTxSigningJob,
    >,
    /// The hash variant to use for computing the transfer package signing payload.
    #[prost(enumeration = "HashVariant", tag = "6")]
    pub hash_variant: i32,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendLeafKeyTweaks {
    #[prost(message, repeated, tag = "1")]
    pub leaves_to_send: ::prost::alloc::vec::Vec<SendLeafKeyTweak>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendLeafKeyTweak {
    #[prost(string, tag = "1")]
    pub leaf_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub secret_share_tweak: ::core::option::Option<SecretShare>,
    #[prost(map = "string, bytes", tag = "3")]
    pub pubkey_shares_tweak: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::bytes::Bytes,
    >,
    #[prost(bytes = "bytes", tag = "4")]
    pub secret_cipher: ::prost::bytes::Bytes,
    /// Signature over Sha256(leaf_id||transfer_id||secret_cipher)
    #[prost(bytes = "bytes", tag = "5")]
    pub signature: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "6")]
    pub refund_signature: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "7")]
    pub direct_refund_signature: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "8")]
    pub direct_from_cpfp_refund_signature: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeTransferRequest {
    #[prost(string, tag = "1")]
    pub transfer_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, repeated, tag = "3")]
    pub leaves_to_send: ::prost::alloc::vec::Vec<SendLeafKeyTweak>,
    #[prost(string, tag = "4")]
    pub spark_payment_intent: ::prost::alloc::string::String,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeTransferWithTransferPackageRequest {
    #[prost(string, tag = "1")]
    pub transfer_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "3")]
    pub transfer_package: ::core::option::Option<TransferPackage>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeTransferResponse {
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<Transfer>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transfer {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub sender_identity_public_key: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "3")]
    pub receiver_identity_public_key: ::prost::bytes::Bytes,
    #[prost(enumeration = "TransferStatus", tag = "4")]
    pub status: i32,
    #[prost(uint64, tag = "5")]
    pub total_value: u64,
    #[prost(message, optional, tag = "6")]
    pub expiry_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "7")]
    pub leaves: ::prost::alloc::vec::Vec<TransferLeaf>,
    #[prost(message, optional, tag = "8")]
    pub created_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "TransferType", tag = "10")]
    pub r#type: i32,
    #[prost(string, tag = "11")]
    pub spark_invoice: ::prost::alloc::string::String,
    #[prost(enumeration = "Network", tag = "12")]
    pub network: i32,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferLeaf {
    #[prost(message, optional, tag = "1")]
    pub leaf: ::core::option::Option<TreeNode>,
    #[prost(bytes = "bytes", tag = "2")]
    pub secret_cipher: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "3")]
    pub signature: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "4")]
    pub intermediate_refund_tx: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "5")]
    pub intermediate_direct_refund_tx: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "6")]
    pub intermediate_direct_from_cpfp_refund_tx: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "7")]
    pub pending_key_tweak_public_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransferFilter {
    #[prost(string, repeated, tag = "3")]
    pub transfer_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "40")]
    pub limit: i64,
    #[prost(int64, tag = "50")]
    pub offset: i64,
    #[prost(enumeration = "TransferType", repeated, tag = "70")]
    pub types: ::prost::alloc::vec::Vec<i32>,
    /// defaults to mainnet when no network is provided.
    #[prost(enumeration = "Network", tag = "4")]
    pub network: i32,
    #[prost(enumeration = "TransferStatus", repeated, tag = "80")]
    pub statuses: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "Order", tag = "5")]
    pub order: i32,
    #[prost(oneof = "transfer_filter::Participant", tags = "1, 2, 60")]
    pub participant: ::core::option::Option<transfer_filter::Participant>,
    #[prost(oneof = "transfer_filter::TimeFilter", tags = "6, 7")]
    pub time_filter: ::core::option::Option<transfer_filter::TimeFilter>,
}
/// Nested message and enum types in `TransferFilter`.
pub mod transfer_filter {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Participant {
        #[prost(bytes, tag = "1")]
        ReceiverIdentityPublicKey(::prost::bytes::Bytes),
        #[prost(bytes, tag = "2")]
        SenderIdentityPublicKey(::prost::bytes::Bytes),
        /// This will include transfers where this public key is the sender or
        /// receiver.
        #[prost(bytes, tag = "60")]
        SenderOrReceiverIdentityPublicKey(::prost::bytes::Bytes),
    }
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum TimeFilter {
        /// Filter transfers created strictly after this timestamp (exclusive)
        #[prost(message, tag = "6")]
        CreatedAfter(::prost_types::Timestamp),
        /// Filter transfers created strictly before this timestamp (exclusive)
        #[prost(message, tag = "7")]
        CreatedBefore(::prost_types::Timestamp),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTransfersResponse {
    #[prost(message, repeated, tag = "1")]
    pub transfers: ::prost::alloc::vec::Vec<Transfer>,
    #[prost(int64, tag = "2")]
    pub offset: i64,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimLeafKeyTweak {
    #[prost(string, tag = "1")]
    pub leaf_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub secret_share_tweak: ::core::option::Option<SecretShare>,
    #[prost(map = "string, bytes", tag = "3")]
    pub pubkey_shares_tweak: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::bytes::Bytes,
    >,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimTransferTweakKeysRequest {
    #[prost(string, tag = "1")]
    pub transfer_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, repeated, tag = "3")]
    pub leaves_to_receive: ::prost::alloc::vec::Vec<ClaimLeafKeyTweak>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimTransferSignRefundsRequest {
    #[prost(string, tag = "1")]
    pub transfer_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, repeated, tag = "3")]
    pub signing_jobs: ::prost::alloc::vec::Vec<LeafRefundTxSigningJob>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimTransferSignRefundsResponse {
    #[prost(message, repeated, tag = "1")]
    pub signing_results: ::prost::alloc::vec::Vec<LeafRefundTxSigningResult>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StorePreimageShareRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub payment_hash: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "2")]
    pub preimage_share: ::core::option::Option<SecretShare>,
    #[prost(uint32, tag = "3")]
    pub threshold: u32,
    #[prost(string, tag = "4")]
    pub invoice_string: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "5")]
    pub user_identity_public_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestedSigningCommitments {
    #[prost(map = "string, message", tag = "1")]
    pub signing_nonce_commitments: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::common::SigningCommitment,
    >,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSigningCommitmentsRequest {
    /// The node IDs for which to get signing commitments.
    #[prost(string, repeated, tag = "1")]
    pub node_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The number of signing commitments to get per node ID.
    #[prost(uint32, tag = "2")]
    pub count: u32,
    /// Alternative to passing the node IDs: the number of node IDs for which to
    /// get signing commitments. Either `node_ids` or `node_id_count` should be
    /// passed, but not both.
    #[prost(uint32, tag = "3")]
    pub node_id_count: u32,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSigningCommitmentsResponse {
    /// A list of signing commitments for each requested node ID. The signing
    /// commitments will be ordered in the same order as the requested node IDs,
    /// repeated for the number of commitments requested. For example, if node_ids
    /// = \[A, B\] and count = 2, the response will contain:
    ///
    /// \[commitment_A1, commitment_B1, commitment_A2, commitment_B2\]
    #[prost(message, repeated, tag = "1")]
    pub signing_commitments: ::prost::alloc::vec::Vec<RequestedSigningCommitments>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigningCommitments {
    /// A map of signing operator ID (i.e. 000...01) to the signing commitment
    /// provided by that operator.
    #[prost(map = "string, message", tag = "1")]
    pub signing_commitments: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::common::SigningCommitment,
    >,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSignedRefund {
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub refund_tx: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "3")]
    pub user_signature: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "4")]
    pub signing_commitments: ::core::option::Option<SigningCommitments>,
    #[prost(message, optional, tag = "5")]
    pub user_signature_commitment: ::core::option::Option<
        super::common::SigningCommitment,
    >,
    #[prost(enumeration = "Network", tag = "6")]
    pub network: i32,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InvoiceAmountProof {
    #[prost(string, tag = "1")]
    pub bolt11_invoice: ::prost::alloc::string::String,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InvoiceAmount {
    #[prost(uint64, tag = "1")]
    pub value_sats: u64,
    #[prost(message, optional, tag = "2")]
    pub invoice_amount_proof: ::core::option::Option<InvoiceAmountProof>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitiatePreimageSwapRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub payment_hash: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "2")]
    pub invoice_amount: ::core::option::Option<InvoiceAmount>,
    #[prost(enumeration = "initiate_preimage_swap_request::Reason", tag = "3")]
    pub reason: i32,
    #[prost(message, optional, tag = "4")]
    pub transfer: ::core::option::Option<StartUserSignedTransferRequest>,
    #[prost(bytes = "bytes", tag = "5")]
    pub receiver_identity_public_key: ::prost::bytes::Bytes,
    #[prost(uint64, tag = "6")]
    pub fee_sats: u64,
    #[prost(message, optional, tag = "7")]
    pub transfer_request: ::core::option::Option<StartTransferRequest>,
}
/// Nested message and enum types in `InitiatePreimageSwapRequest`.
pub mod initiate_preimage_swap_request {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reason {
        /// The associated lightning service is sending the payment.
        Send = 0,
        /// The associated lightning service is receiving the payment.
        Receive = 1,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Send => "REASON_SEND",
                Self::Receive => "REASON_RECEIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_SEND" => Some(Self::Send),
                "REASON_RECEIVE" => Some(Self::Receive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitiatePreimageSwapResponse {
    #[prost(bytes = "bytes", tag = "1")]
    pub preimage: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "2")]
    pub transfer: ::core::option::Option<Transfer>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OutPoint {
    #[prost(bytes = "bytes", tag = "1")]
    pub txid: ::prost::bytes::Bytes,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CooperativeExitRequest {
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<StartTransferRequest>,
    #[prost(string, tag = "2")]
    pub exit_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "3")]
    pub exit_txid: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "4")]
    pub connector_tx: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CooperativeExitResponse {
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<Transfer>,
    #[prost(message, repeated, tag = "2")]
    pub signing_results: ::prost::alloc::vec::Vec<LeafRefundTxSigningResult>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CounterLeafSwapRequest {
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<StartTransferRequest>,
    #[prost(string, tag = "2")]
    pub swap_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "3")]
    pub adaptor_public_key: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "4")]
    pub direct_adaptor_public_key: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "5")]
    pub direct_from_cpfp_adaptor_public_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CounterLeafSwapResponse {
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<Transfer>,
    #[prost(message, repeated, tag = "2")]
    pub signing_results: ::prost::alloc::vec::Vec<LeafRefundTxSigningResult>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshTimelockRequest {
    #[prost(string, tag = "1")]
    pub leaf_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, repeated, tag = "3")]
    pub signing_jobs: ::prost::alloc::vec::Vec<SigningJob>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshTimelockSigningResult {
    #[prost(message, optional, tag = "1")]
    pub signing_result: ::core::option::Option<SigningResult>,
    /// Should maybe just be a part of SigningResult?
    #[prost(bytes = "bytes", tag = "2")]
    pub verifying_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshTimelockResponse {
    #[prost(message, repeated, tag = "1")]
    pub signing_results: ::prost::alloc::vec::Vec<RefreshTimelockSigningResult>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExtendLeafRequest {
    #[prost(string, tag = "1")]
    pub leaf_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "3")]
    pub node_tx_signing_job: ::core::option::Option<SigningJob>,
    #[prost(message, optional, tag = "4")]
    pub refund_tx_signing_job: ::core::option::Option<SigningJob>,
    #[prost(message, optional, tag = "5")]
    pub direct_node_tx_signing_job: ::core::option::Option<SigningJob>,
    #[prost(message, optional, tag = "6")]
    pub direct_refund_tx_signing_job: ::core::option::Option<SigningJob>,
    #[prost(message, optional, tag = "7")]
    pub direct_from_cpfp_refund_tx_signing_job: ::core::option::Option<SigningJob>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtendLeafSigningResult {
    #[prost(message, optional, tag = "1")]
    pub signing_result: ::core::option::Option<SigningResult>,
    #[prost(bytes = "bytes", tag = "2")]
    pub verifying_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtendLeafResponse {
    #[prost(string, tag = "1")]
    pub leaf_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub node_tx_signing_result: ::core::option::Option<ExtendLeafSigningResult>,
    #[prost(message, optional, tag = "3")]
    pub refund_tx_signing_result: ::core::option::Option<ExtendLeafSigningResult>,
    #[prost(message, optional, tag = "4")]
    pub direct_node_tx_signing_result: ::core::option::Option<ExtendLeafSigningResult>,
    #[prost(message, optional, tag = "5")]
    pub direct_refund_tx_signing_result: ::core::option::Option<ExtendLeafSigningResult>,
    #[prost(message, optional, tag = "6")]
    pub direct_from_cpfp_refund_tx_signing_result: ::core::option::Option<
        ExtendLeafSigningResult,
    >,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressRequestNode {
    #[prost(bytes = "bytes", tag = "1")]
    pub user_public_key: ::prost::bytes::Bytes,
    #[prost(message, repeated, tag = "2")]
    pub children: ::prost::alloc::vec::Vec<AddressRequestNode>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrepareTreeAddressRequest {
    /// The tx on this node is to spend the source's utxo.
    /// The user's public key should already be registered with the SE for the root
    /// node.
    #[prost(message, optional, tag = "3")]
    pub node: ::core::option::Option<AddressRequestNode>,
    #[prost(bytes = "bytes", tag = "4")]
    pub user_identity_public_key: ::prost::bytes::Bytes,
    #[prost(oneof = "prepare_tree_address_request::Source", tags = "1, 2")]
    pub source: ::core::option::Option<prepare_tree_address_request::Source>,
}
/// Nested message and enum types in `PrepareTreeAddressRequest`.
pub mod prepare_tree_address_request {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        ParentNodeOutput(super::NodeOutput),
        #[prost(message, tag = "2")]
        OnChainUtxo(super::Utxo),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressNode {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<Address>,
    #[prost(message, repeated, tag = "2")]
    pub children: ::prost::alloc::vec::Vec<AddressNode>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrepareTreeAddressResponse {
    #[prost(message, optional, tag = "1")]
    pub node: ::core::option::Option<AddressNode>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreationNode {
    /// This is the cpfp tx that spends the parent node's output.
    #[prost(message, optional, tag = "1")]
    pub node_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The refund tx can only exist if there's no children.
    #[prost(message, optional, tag = "2")]
    pub refund_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The children will spend the output of the node's tx. Vout is the index of
    /// the child.
    #[prost(message, repeated, tag = "3")]
    pub children: ::prost::alloc::vec::Vec<CreationNode>,
    /// This is the direct tx that spends the parent node's output.
    #[prost(message, optional, tag = "4")]
    pub direct_node_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The direct refund tx can only exist if there's no children.
    #[prost(message, optional, tag = "5")]
    pub direct_refund_tx_signing_job: ::core::option::Option<SigningJob>,
    /// The direct from cpfp refund tx can only exist if there's no children.
    #[prost(message, optional, tag = "6")]
    pub direct_from_cpfp_refund_tx_signing_job: ::core::option::Option<SigningJob>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTreeRequest {
    /// The node should contain the tx that spends the source's utxo.
    #[prost(message, optional, tag = "3")]
    pub node: ::core::option::Option<CreationNode>,
    /// The owner of the tree.
    #[prost(bytes = "bytes", tag = "4")]
    pub user_identity_public_key: ::prost::bytes::Bytes,
    #[prost(oneof = "create_tree_request::Source", tags = "1, 2")]
    pub source: ::core::option::Option<create_tree_request::Source>,
}
/// Nested message and enum types in `CreateTreeRequest`.
pub mod create_tree_request {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        ParentNodeOutput(super::NodeOutput),
        #[prost(message, tag = "2")]
        OnChainUtxo(super::Utxo),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreationResponseNode {
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub node_tx_signing_result: ::core::option::Option<SigningResult>,
    #[prost(message, optional, tag = "3")]
    pub refund_tx_signing_result: ::core::option::Option<SigningResult>,
    #[prost(message, repeated, tag = "4")]
    pub children: ::prost::alloc::vec::Vec<CreationResponseNode>,
    #[prost(message, optional, tag = "5")]
    pub direct_node_tx_signing_result: ::core::option::Option<SigningResult>,
    #[prost(message, optional, tag = "6")]
    pub direct_refund_tx_signing_result: ::core::option::Option<SigningResult>,
    #[prost(message, optional, tag = "7")]
    pub direct_from_cpfp_refund_tx_signing_result: ::core::option::Option<SigningResult>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTreeResponse {
    #[prost(message, optional, tag = "1")]
    pub node: ::core::option::Option<CreationResponseNode>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SigningOperatorInfo {
    #[prost(uint64, tag = "1")]
    pub index: u64,
    #[prost(string, tag = "2")]
    pub identifier: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "3")]
    pub public_key: ::prost::bytes::Bytes,
    #[prost(string, tag = "4")]
    pub address: ::prost::alloc::string::String,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSigningOperatorListResponse {
    #[prost(map = "string, message", tag = "1")]
    pub signing_operators: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SigningOperatorInfo,
    >,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryUserSignedRefundsRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub payment_hash: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "2")]
    pub identity_public_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUserSignedRefundsResponse {
    #[prost(message, repeated, tag = "1")]
    pub user_signed_refunds: ::prost::alloc::vec::Vec<UserSignedRefund>,
    #[prost(message, optional, tag = "3")]
    pub transfer: ::core::option::Option<Transfer>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreimageRequestWithTransfer {
    /// Preimage request data
    #[prost(bytes = "bytes", tag = "1")]
    pub payment_hash: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "2")]
    pub receiver_identity_pubkey: ::prost::bytes::Bytes,
    #[prost(enumeration = "PreimageRequestStatus", tag = "3")]
    pub status: i32,
    #[prost(message, optional, tag = "4")]
    pub created_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Associated transfer (if exists)
    #[prost(message, optional, tag = "5")]
    pub transfer: ::core::option::Option<Transfer>,
    /// Preimage data (if available)
    #[prost(bytes = "bytes", optional, tag = "6")]
    pub preimage: ::core::option::Option<::prost::bytes::Bytes>,
    /// The identity public key of the sender can potentially be null for old
    /// preimage requests.
    #[prost(bytes = "bytes", tag = "7")]
    pub sender_identity_pubkey: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryHtlcRequest {
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub payment_hashes: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", tag = "2")]
    pub identity_public_key: ::prost::bytes::Bytes,
    #[prost(enumeration = "PreimageRequestStatus", optional, tag = "3")]
    pub status: ::core::option::Option<i32>,
    /// defaults to 100 if not set.
    #[prost(int64, tag = "4")]
    pub limit: i64,
    /// defaults to 0 if not set.
    #[prost(int64, tag = "5")]
    pub offset: i64,
    #[prost(string, repeated, tag = "6")]
    pub transfer_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// defaults to PREIMAGE_REQUEST_ROLE_RECEIVER if not set.
    #[prost(enumeration = "PreimageRequestRole", tag = "7")]
    pub match_role: i32,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryHtlcResponse {
    #[prost(message, repeated, tag = "1")]
    pub preimage_requests: ::prost::alloc::vec::Vec<PreimageRequestWithTransfer>,
    /// defaults to -1 if there are no more results
    #[prost(int64, tag = "2")]
    pub offset: i64,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProvidePreimageRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub payment_hash: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "2")]
    pub preimage: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "3")]
    pub identity_public_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvidePreimageResponse {
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<Transfer>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryPreimageRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub payment_hash: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryPreimageResponse {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub preimage: ::core::option::Option<::prost::bytes::Bytes>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreeNodeIds {
    #[prost(string, repeated, tag = "1")]
    pub node_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryNodesRequest {
    #[prost(bool, tag = "3")]
    pub include_parents: bool,
    #[prost(int64, tag = "4")]
    pub limit: i64,
    #[prost(int64, tag = "5")]
    pub offset: i64,
    /// defaults to mainnet when no network is provided. Does
    #[prost(enumeration = "Network", tag = "6")]
    pub network: i32,
    /// not check network when querying by node_ids
    #[prost(enumeration = "TreeNodeStatus", repeated, tag = "7")]
    pub statuses: ::prost::alloc::vec::Vec<i32>,
    #[prost(oneof = "query_nodes_request::Source", tags = "1, 2")]
    pub source: ::core::option::Option<query_nodes_request::Source>,
}
/// Nested message and enum types in `QueryNodesRequest`.
pub mod query_nodes_request {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Source {
        #[prost(bytes, tag = "1")]
        OwnerIdentityPubkey(::prost::bytes::Bytes),
        #[prost(message, tag = "2")]
        NodeIds(super::TreeNodeIds),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryNodesResponse {
    #[prost(map = "string, message", tag = "1")]
    pub nodes: ::std::collections::HashMap<::prost::alloc::string::String, TreeNode>,
    #[prost(int64, tag = "2")]
    pub offset: i64,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CancelTransferRequest {
    #[prost(string, tag = "1")]
    pub transfer_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub sender_identity_public_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTransferResponse {
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<Transfer>,
}
/// *
/// Returns a list of addresses that can be used in express deposit flow.
/// Excludes static deposit addresses.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryUnusedDepositAddressesRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub identity_public_key: ::prost::bytes::Bytes,
    /// defaults to mainnet when no network is provided.
    #[prost(enumeration = "Network", tag = "2")]
    pub network: i32,
    /// defaults to 100 if not set.
    #[prost(int64, tag = "3")]
    pub limit: i64,
    /// defaults to 0 if not set.
    #[prost(int64, tag = "4")]
    pub offset: i64,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryStaticDepositAddressesRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub identity_public_key: ::prost::bytes::Bytes,
    /// defaults to mainnet when no network is provided.
    #[prost(enumeration = "Network", tag = "2")]
    pub network: i32,
    #[prost(int64, tag = "4")]
    pub limit: i64,
    #[prost(int64, tag = "5")]
    pub offset: i64,
    /// Optional filter. When specified, only the DepositAddress with this address
    /// is returned.
    #[prost(string, optional, tag = "6")]
    pub deposit_address: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DepositAddressQueryResult {
    #[prost(string, tag = "1")]
    pub deposit_address: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub user_signing_public_key: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "3")]
    pub verifying_public_key: ::prost::bytes::Bytes,
    #[prost(string, optional, tag = "4")]
    pub leaf_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub proof_of_possession: ::core::option::Option<DepositAddressProof>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUnusedDepositAddressesResponse {
    #[prost(message, repeated, tag = "1")]
    pub deposit_addresses: ::prost::alloc::vec::Vec<DepositAddressQueryResult>,
    /// defaults to -1 if there are no more results
    #[prost(int64, tag = "2")]
    pub offset: i64,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStaticDepositAddressesResponse {
    #[prost(message, repeated, tag = "1")]
    pub deposit_addresses: ::prost::alloc::vec::Vec<DepositAddressQueryResult>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryBalanceRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub identity_public_key: ::prost::bytes::Bytes,
    /// defaults to mainnet when no network is provided.
    #[prost(enumeration = "Network", tag = "2")]
    pub network: i32,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalanceResponse {
    #[prost(uint64, tag = "1")]
    pub balance: u64,
    #[prost(map = "string, uint64", tag = "2")]
    pub node_balances: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SparkAddress {
    #[prost(bytes = "bytes", tag = "1")]
    pub identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "2")]
    pub spark_invoice_fields: ::core::option::Option<SparkInvoiceFields>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SparkInvoiceFields {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(bytes = "bytes", tag = "2")]
    pub id: ::prost::bytes::Bytes,
    #[prost(string, optional, tag = "5")]
    pub memo: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "bytes", optional, tag = "6")]
    pub sender_public_key: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(message, optional, tag = "7")]
    pub expiry_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "spark_invoice_fields::PaymentType", tags = "3, 4")]
    pub payment_type: ::core::option::Option<spark_invoice_fields::PaymentType>,
}
/// Nested message and enum types in `SparkInvoiceFields`.
pub mod spark_invoice_fields {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum PaymentType {
        #[prost(message, tag = "3")]
        TokensPayment(super::TokensPayment),
        #[prost(message, tag = "4")]
        SatsPayment(super::SatsPayment),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SatsPayment {
    #[prost(uint64, optional, tag = "1")]
    pub amount: ::core::option::Option<u64>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TokensPayment {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub token_identifier: ::core::option::Option<::prost::bytes::Bytes>,
    /// variable length uint128
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub amount: ::core::option::Option<::prost::bytes::Bytes>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InitiateStaticDepositUtxoRefundRequest {
    #[prost(message, optional, tag = "1")]
    pub on_chain_utxo: ::core::option::Option<Utxo>,
    /// A package that is used for signing L1 Bitcoin transactions using FROST.
    /// SE consumes it to return SigningResult structure, that is used by the user
    /// to construct the final signature for the refund Bitcoin transaction.
    #[prost(message, optional, tag = "3")]
    pub refund_tx_signing_job: ::core::option::Option<SigningJob>,
    /// Signature of a user statement that authorises the SE to initiate a static
    /// deposit utxo refund to the user.
    ///
    /// The user statement is constructed by concatenating the following fields in
    /// order:
    /// 1. Action name: "claim_static_deposit" (UTF-8 string)
    /// 2. Network: lowercase network name (e.g., "bitcoin", "testnet") (UTF-8
    /// string)
    /// 3. Transaction ID: hex-encoded UTXO transaction ID (UTF-8 string)
    /// 4. Output index: UTXO output index (vout) as 4-byte unsigned integer
    /// (little-endian)
    /// 5. Request type: 2 for refund (1-byte unsigned integer, little-endian)
    /// 6. Credit amount: amount of satoshis to credit as 8-byte unsigned integer
    /// (little-endian)
    /// 7. Signing payload: sighash of spend transaction (UTF-8 string)
    ///
    /// The concatenated payload is then hashed with SHA-256, and the resulting
    /// hash is signed using ECDSA with the user's identity private key to produce
    /// this signature.
    #[prost(bytes = "bytes", tag = "4")]
    pub user_signature: ::prost::bytes::Bytes,
    /// Optional: which hash variant was used to create user_signature.
    #[prost(enumeration = "HashVariant", tag = "5")]
    pub hash_variant: i32,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitiateStaticDepositUtxoRefundResponse {
    /// The FROST signing results which must be aggregated by the user to complete
    /// signing
    #[prost(message, optional, tag = "1")]
    pub refund_tx_signing_result: ::core::option::Option<SigningResult>,
    #[prost(message, optional, tag = "2")]
    pub deposit_address: ::core::option::Option<DepositAddressQueryResult>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitiateUtxoSwapRequest {
    #[prost(message, optional, tag = "1")]
    pub on_chain_utxo: ::core::option::Option<Utxo>,
    #[prost(enumeration = "UtxoSwapRequestType", tag = "2")]
    pub request_type: i32,
    #[prost(bytes = "bytes", tag = "5")]
    pub ssp_signature: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "6")]
    pub user_signature: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "7")]
    pub transfer: ::core::option::Option<StartTransferRequest>,
    #[prost(message, optional, tag = "8")]
    pub spend_tx_signing_job: ::core::option::Option<SigningJob>,
    #[prost(oneof = "initiate_utxo_swap_request::Amount", tags = "3, 4")]
    pub amount: ::core::option::Option<initiate_utxo_swap_request::Amount>,
}
/// Nested message and enum types in `InitiateUtxoSwapRequest`.
pub mod initiate_utxo_swap_request {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Amount {
        #[prost(uint64, tag = "3")]
        CreditAmountSats(u64),
        #[prost(uint64, tag = "4")]
        MaxFeeSats(u64),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitiateUtxoSwapResponse {
    #[prost(message, optional, tag = "1")]
    pub spend_tx_signing_result: ::core::option::Option<SigningResult>,
    #[prost(message, optional, tag = "2")]
    pub transfer: ::core::option::Option<Transfer>,
    #[prost(message, optional, tag = "3")]
    pub deposit_address: ::core::option::Option<DepositAddressQueryResult>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExitingTree {
    #[prost(string, tag = "1")]
    pub tree_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub user_signing_commitment: ::core::option::Option<
        super::common::SigningCommitment,
    >,
    #[prost(uint32, tag = "3")]
    pub vin: u32,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExitSingleNodeTreeSigningResult {
    #[prost(string, tag = "1")]
    pub tree_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub signing_result: ::core::option::Option<SigningResult>,
    #[prost(bytes = "bytes", tag = "3")]
    pub verifying_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BitcoinTransactionOutput {
    #[prost(int64, tag = "1")]
    pub value: i64,
    #[prost(bytes = "bytes", tag = "2")]
    pub pk_script: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExitSingleNodeTreesRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    #[prost(message, repeated, tag = "2")]
    pub exiting_trees: ::prost::alloc::vec::Vec<ExitingTree>,
    #[prost(bytes = "bytes", tag = "3")]
    pub raw_tx: ::prost::bytes::Bytes,
    #[prost(message, repeated, tag = "4")]
    pub previous_outputs: ::prost::alloc::vec::Vec<BitcoinTransactionOutput>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExitSingleNodeTreesResponse {
    #[prost(message, repeated, tag = "1")]
    pub signing_results: ::prost::alloc::vec::Vec<ExitSingleNodeTreeSigningResult>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryNodesDistributionRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryNodesDistributionResponse {
    #[prost(map = "uint64, uint64", tag = "1")]
    pub node_distribution: ::std::collections::HashMap<u64, u64>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryNodesByValueRequest {
    #[prost(bytes = "bytes", tag = "1")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    #[prost(int64, tag = "2")]
    pub value: i64,
    #[prost(int64, tag = "3")]
    pub offset: i64,
    #[prost(int64, tag = "4")]
    pub limit: i64,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryNodesByValueResponse {
    #[prost(map = "string, message", tag = "1")]
    pub nodes: ::std::collections::HashMap<::prost::alloc::string::String, TreeNode>,
    #[prost(int64, tag = "2")]
    pub offset: i64,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetUtxosForAddressRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub offset: u64,
    #[prost(uint64, tag = "3")]
    pub limit: u64,
    #[prost(enumeration = "Network", tag = "4")]
    pub network: i32,
    #[prost(bool, tag = "5")]
    pub exclude_claimed: bool,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUtxosForAddressResponse {
    #[prost(message, repeated, tag = "1")]
    pub utxos: ::prost::alloc::vec::Vec<Utxo>,
    #[prost(uint64, tag = "2")]
    pub offset: u64,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuerySparkInvoicesRequest {
    #[prost(int64, tag = "1")]
    pub limit: i64,
    #[prost(int64, tag = "2")]
    pub offset: i64,
    /// returns the status for the provided list of spark invoices.
    #[prost(string, repeated, tag = "3")]
    pub invoice: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySparkInvoicesResponse {
    #[prost(int64, tag = "1")]
    pub offset: i64,
    #[prost(message, repeated, tag = "2")]
    pub invoice_statuses: ::prost::alloc::vec::Vec<InvoiceResponse>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InvoiceResponse {
    #[prost(string, tag = "1")]
    pub invoice: ::prost::alloc::string::String,
    #[prost(enumeration = "InvoiceStatus", tag = "2")]
    pub status: i32,
    #[prost(oneof = "invoice_response::TransferType", tags = "3, 4")]
    pub transfer_type: ::core::option::Option<invoice_response::TransferType>,
}
/// Nested message and enum types in `InvoiceResponse`.
pub mod invoice_response {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum TransferType {
        #[prost(message, tag = "3")]
        SatsTransfer(super::SatsTransfer),
        #[prost(message, tag = "4")]
        TokenTransfer(super::TokenTransfer),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SatsTransfer {
    #[prost(bytes = "bytes", tag = "1")]
    pub transfer_id: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TokenTransfer {
    #[prost(bytes = "bytes", tag = "1")]
    pub final_token_transaction_hash: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitiateSwapPrimaryTransferRequest {
    /// Transfer with refunds and key tweaks signed
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<StartTransferRequest>,
    /// Adaptor public keys to verify the signatures of refunds for the primary
    /// transfer in the swap
    #[prost(message, optional, tag = "2")]
    pub adaptor_public_keys: ::core::option::Option<AdaptorPublicKeyPackage>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitiateSwapPrimaryTransferResponse {
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<Transfer>,
    #[prost(message, repeated, tag = "2")]
    pub signing_results: ::prost::alloc::vec::Vec<LeafRefundTxSigningResult>,
}
/// Adaptor public key is derived from the secret `t` using formula:
/// ```
/// T = t * G
/// ```
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdaptorPublicKeyPackage {
    #[prost(bytes = "bytes", tag = "1")]
    pub adaptor_public_key: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "2")]
    pub direct_adaptor_public_key: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "3")]
    pub direct_from_cpfp_adaptor_public_key: ::prost::bytes::Bytes,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WalletSetting {
    #[prost(bytes = "bytes", tag = "1")]
    pub owner_identity_public_key: ::prost::bytes::Bytes,
    #[prost(bool, tag = "2")]
    pub private_enabled: bool,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub master_identity_public_key: ::core::option::Option<::prost::bytes::Bytes>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateWalletSettingRequest {
    #[prost(bool, optional, tag = "1")]
    pub private_enabled: ::core::option::Option<bool>,
    #[prost(
        oneof = "update_wallet_setting_request::MasterIdentityPublicKey",
        tags = "2, 3"
    )]
    pub master_identity_public_key: ::core::option::Option<
        update_wallet_setting_request::MasterIdentityPublicKey,
    >,
}
/// Nested message and enum types in `UpdateWalletSettingRequest`.
pub mod update_wallet_setting_request {
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum MasterIdentityPublicKey {
        #[prost(bytes, tag = "2")]
        SetMasterIdentityPublicKey(::prost::bytes::Bytes),
        #[prost(bool, tag = "3")]
        ClearMasterIdentityPublicKey(bool),
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateWalletSettingResponse {
    #[prost(message, optional, tag = "1")]
    pub wallet_setting: ::core::option::Option<WalletSetting>,
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryWalletSettingRequest {}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryWalletSettingResponse {
    #[prost(message, optional, tag = "1")]
    pub wallet_setting: ::core::option::Option<WalletSetting>,
}
/// *
/// Network is the network type of the bitcoin network.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Network {
    Unspecified = 0,
    Mainnet = 1,
    Regtest = 2,
    Testnet = 3,
    Signet = 4,
}
impl Network {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNSPECIFIED",
            Self::Mainnet => "MAINNET",
            Self::Regtest => "REGTEST",
            Self::Testnet => "TESTNET",
            Self::Signet => "SIGNET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "MAINNET" => Some(Self::Mainnet),
            "REGTEST" => Some(Self::Regtest),
            "TESTNET" => Some(Self::Testnet),
            "SIGNET" => Some(Self::Signet),
            _ => None,
        }
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Direction {
    Next = 0,
    Previous = 1,
}
impl Direction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Next => "NEXT",
            Self::Previous => "PREVIOUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NEXT" => Some(Self::Next),
            "PREVIOUS" => Some(Self::Previous),
            _ => None,
        }
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransferStatus {
    SenderInitiated = 0,
    SenderKeyTweakPending = 1,
    SenderKeyTweaked = 2,
    ReceiverKeyTweaked = 3,
    ReceiverRefundSigned = 4,
    Completed = 5,
    Expired = 6,
    Returned = 7,
    SenderInitiatedCoordinator = 8,
    ReceiverKeyTweakLocked = 9,
    ReceiverKeyTweakApplied = 10,
    ApplyingSenderKeyTweak = 11,
}
impl TransferStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SenderInitiated => "TRANSFER_STATUS_SENDER_INITIATED",
            Self::SenderKeyTweakPending => "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING",
            Self::SenderKeyTweaked => "TRANSFER_STATUS_SENDER_KEY_TWEAKED",
            Self::ReceiverKeyTweaked => "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED",
            Self::ReceiverRefundSigned => "TRANSFER_STATUS_RECEIVER_REFUND_SIGNED",
            Self::Completed => "TRANSFER_STATUS_COMPLETED",
            Self::Expired => "TRANSFER_STATUS_EXPIRED",
            Self::Returned => "TRANSFER_STATUS_RETURNED",
            Self::SenderInitiatedCoordinator => {
                "TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR"
            }
            Self::ReceiverKeyTweakLocked => "TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED",
            Self::ReceiverKeyTweakApplied => "TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED",
            Self::ApplyingSenderKeyTweak => "TRANSFER_STATUS_APPLYING_SENDER_KEY_TWEAK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSFER_STATUS_SENDER_INITIATED" => Some(Self::SenderInitiated),
            "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING" => {
                Some(Self::SenderKeyTweakPending)
            }
            "TRANSFER_STATUS_SENDER_KEY_TWEAKED" => Some(Self::SenderKeyTweaked),
            "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED" => Some(Self::ReceiverKeyTweaked),
            "TRANSFER_STATUS_RECEIVER_REFUND_SIGNED" => Some(Self::ReceiverRefundSigned),
            "TRANSFER_STATUS_COMPLETED" => Some(Self::Completed),
            "TRANSFER_STATUS_EXPIRED" => Some(Self::Expired),
            "TRANSFER_STATUS_RETURNED" => Some(Self::Returned),
            "TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR" => {
                Some(Self::SenderInitiatedCoordinator)
            }
            "TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED" => {
                Some(Self::ReceiverKeyTweakLocked)
            }
            "TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED" => {
                Some(Self::ReceiverKeyTweakApplied)
            }
            "TRANSFER_STATUS_APPLYING_SENDER_KEY_TWEAK" => {
                Some(Self::ApplyingSenderKeyTweak)
            }
            _ => None,
        }
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransferType {
    PreimageSwap = 0,
    CooperativeExit = 1,
    Transfer = 2,
    UtxoSwap = 3,
    Swap = 30,
    CounterSwap = 40,
    PrimarySwapV3 = 4,
    CounterSwapV3 = 5,
}
impl TransferType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PreimageSwap => "PREIMAGE_SWAP",
            Self::CooperativeExit => "COOPERATIVE_EXIT",
            Self::Transfer => "TRANSFER",
            Self::UtxoSwap => "UTXO_SWAP",
            Self::Swap => "SWAP",
            Self::CounterSwap => "COUNTER_SWAP",
            Self::PrimarySwapV3 => "PRIMARY_SWAP_V3",
            Self::CounterSwapV3 => "COUNTER_SWAP_V3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PREIMAGE_SWAP" => Some(Self::PreimageSwap),
            "COOPERATIVE_EXIT" => Some(Self::CooperativeExit),
            "TRANSFER" => Some(Self::Transfer),
            "UTXO_SWAP" => Some(Self::UtxoSwap),
            "SWAP" => Some(Self::Swap),
            "COUNTER_SWAP" => Some(Self::CounterSwap),
            "PRIMARY_SWAP_V3" => Some(Self::PrimarySwapV3),
            "COUNTER_SWAP_V3" => Some(Self::CounterSwapV3),
            _ => None,
        }
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Order {
    Descending = 0,
    Ascending = 1,
}
impl Order {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Descending => "DESCENDING",
            Self::Ascending => "ASCENDING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DESCENDING" => Some(Self::Descending),
            "ASCENDING" => Some(Self::Ascending),
            _ => None,
        }
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PreimageRequestStatus {
    WaitingForPreimage = 0,
    PreimageShared = 1,
    Returned = 2,
}
impl PreimageRequestStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::WaitingForPreimage => "PREIMAGE_REQUEST_STATUS_WAITING_FOR_PREIMAGE",
            Self::PreimageShared => "PREIMAGE_REQUEST_STATUS_PREIMAGE_SHARED",
            Self::Returned => "PREIMAGE_REQUEST_STATUS_RETURNED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PREIMAGE_REQUEST_STATUS_WAITING_FOR_PREIMAGE" => {
                Some(Self::WaitingForPreimage)
            }
            "PREIMAGE_REQUEST_STATUS_PREIMAGE_SHARED" => Some(Self::PreimageShared),
            "PREIMAGE_REQUEST_STATUS_RETURNED" => Some(Self::Returned),
            _ => None,
        }
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PreimageRequestRole {
    Receiver = 0,
    Sender = 1,
    ReceiverAndSender = 2,
}
impl PreimageRequestRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Receiver => "PREIMAGE_REQUEST_ROLE_RECEIVER",
            Self::Sender => "PREIMAGE_REQUEST_ROLE_SENDER",
            Self::ReceiverAndSender => "PREIMAGE_REQUEST_ROLE_RECEIVER_AND_SENDER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PREIMAGE_REQUEST_ROLE_RECEIVER" => Some(Self::Receiver),
            "PREIMAGE_REQUEST_ROLE_SENDER" => Some(Self::Sender),
            "PREIMAGE_REQUEST_ROLE_RECEIVER_AND_SENDER" => Some(Self::ReceiverAndSender),
            _ => None,
        }
    }
}
/// *
/// Static deposit address flow messages
///
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UtxoSwapRequestType {
    Fixed = 0,
    MaxFee = 1,
    Refund = 2,
}
impl UtxoSwapRequestType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Fixed => "Fixed",
            Self::MaxFee => "MaxFee",
            Self::Refund => "Refund",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Fixed" => Some(Self::Fixed),
            "MaxFee" => Some(Self::MaxFee),
            "Refund" => Some(Self::Refund),
            _ => None,
        }
    }
}
/// Which hash variant to use in cryptographic operations.
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashVariant {
    /// Legacy
    Unspecified = 0,
    /// Structured hashing
    V2 = 1,
}
impl HashVariant {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HASH_VARIANT_UNSPECIFIED",
            Self::V2 => "HASH_VARIANT_V2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HASH_VARIANT_UNSPECIFIED" => Some(Self::Unspecified),
            "HASH_VARIANT_V2" => Some(Self::V2),
            _ => None,
        }
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InvoiceStatus {
    NotFound = 0,
    Pending = 1,
    Finalized = 2,
    Returned = 4,
}
impl InvoiceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NotFound => "NOT_FOUND",
            Self::Pending => "PENDING",
            Self::Finalized => "FINALIZED",
            Self::Returned => "RETURNED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NOT_FOUND" => Some(Self::NotFound),
            "PENDING" => Some(Self::Pending),
            "FINALIZED" => Some(Self::Finalized),
            "RETURNED" => Some(Self::Returned),
            _ => None,
        }
    }
}
#[allow(clippy::large_enum_variant)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TreeNodeStatus {
    Creating = 0,
    Available = 1,
    FrozenByIssuer = 2,
    TransferLocked = 3,
    SplitLocked = 4,
    Splitted = 5,
    Aggregated = 6,
    OnChain = 7,
    AggregateLock = 8,
    Exited = 9,
    RenewLocked = 10,
}
impl TreeNodeStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Creating => "TREE_NODE_STATUS_CREATING",
            Self::Available => "TREE_NODE_STATUS_AVAILABLE",
            Self::FrozenByIssuer => "TREE_NODE_STATUS_FROZEN_BY_ISSUER",
            Self::TransferLocked => "TREE_NODE_STATUS_TRANSFER_LOCKED",
            Self::SplitLocked => "TREE_NODE_STATUS_SPLIT_LOCKED",
            Self::Splitted => "TREE_NODE_STATUS_SPLITTED",
            Self::Aggregated => "TREE_NODE_STATUS_AGGREGATED",
            Self::OnChain => "TREE_NODE_STATUS_ON_CHAIN",
            Self::AggregateLock => "TREE_NODE_STATUS_AGGREGATE_LOCK",
            Self::Exited => "TREE_NODE_STATUS_EXITED",
            Self::RenewLocked => "TREE_NODE_STATUS_RENEW_LOCKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TREE_NODE_STATUS_CREATING" => Some(Self::Creating),
            "TREE_NODE_STATUS_AVAILABLE" => Some(Self::Available),
            "TREE_NODE_STATUS_FROZEN_BY_ISSUER" => Some(Self::FrozenByIssuer),
            "TREE_NODE_STATUS_TRANSFER_LOCKED" => Some(Self::TransferLocked),
            "TREE_NODE_STATUS_SPLIT_LOCKED" => Some(Self::SplitLocked),
            "TREE_NODE_STATUS_SPLITTED" => Some(Self::Splitted),
            "TREE_NODE_STATUS_AGGREGATED" => Some(Self::Aggregated),
            "TREE_NODE_STATUS_ON_CHAIN" => Some(Self::OnChain),
            "TREE_NODE_STATUS_AGGREGATE_LOCK" => Some(Self::AggregateLock),
            "TREE_NODE_STATUS_EXITED" => Some(Self::Exited),
            "TREE_NODE_STATUS_RENEW_LOCKED" => Some(Self::RenewLocked),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod spark_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SparkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SparkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SparkServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SparkServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn generate_deposit_address(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateDepositAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateDepositAddressResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/generate_deposit_address",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("spark.SparkService", "generate_deposit_address"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a new static deposit address of the user or returns the existing
        /// one for the specified network.
        pub async fn generate_static_deposit_address(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateStaticDepositAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateStaticDepositAddressResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/generate_static_deposit_address",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "spark.SparkService",
                        "generate_static_deposit_address",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Archives the current default static deposit address and generates a new one
        /// for the user.
        pub async fn rotate_static_deposit_address(
            &mut self,
            request: impl tonic::IntoRequest<super::RotateStaticDepositAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RotateStaticDepositAddressResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/rotate_static_deposit_address",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "spark.SparkService",
                        "rotate_static_deposit_address",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_deposit_tree_creation(
            &mut self,
            request: impl tonic::IntoRequest<super::StartDepositTreeCreationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartDepositTreeCreationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/start_deposit_tree_creation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("spark.SparkService", "start_deposit_tree_creation"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a deposit tree with the commitments from get_signing_commitments,
        /// after they are signed. Fails if the tree already exists.
        pub async fn finalize_deposit_tree_creation(
            &mut self,
            request: impl tonic::IntoRequest<super::FinalizeDepositTreeCreationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FinalizeDepositTreeCreationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/finalize_deposit_tree_creation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "spark.SparkService",
                        "finalize_deposit_tree_creation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn finalize_transfer_with_transfer_package(
            &mut self,
            request: impl tonic::IntoRequest<
                super::FinalizeTransferWithTransferPackageRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::FinalizeTransferResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/finalize_transfer_with_transfer_package",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "spark.SparkService",
                        "finalize_transfer_with_transfer_package",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_pending_transfers(
            &mut self,
            request: impl tonic::IntoRequest<super::TransferFilter>,
        ) -> std::result::Result<
            tonic::Response<super::QueryTransfersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_pending_transfers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("spark.SparkService", "query_pending_transfers"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_all_transfers(
            &mut self,
            request: impl tonic::IntoRequest<super::TransferFilter>,
        ) -> std::result::Result<
            tonic::Response<super::QueryTransfersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_all_transfers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "query_all_transfers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn claim_transfer_tweak_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::ClaimTransferTweakKeysRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/claim_transfer_tweak_keys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("spark.SparkService", "claim_transfer_tweak_keys"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn store_preimage_share(
            &mut self,
            request: impl tonic::IntoRequest<super::StorePreimageShareRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/store_preimage_share",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "store_preimage_share"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a specified number of signing commmitments for a set of nodes, which
        /// can be used as part of a transfer package.
        pub async fn get_signing_commitments(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSigningCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSigningCommitmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/get_signing_commitments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("spark.SparkService", "get_signing_commitments"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn provide_preimage(
            &mut self,
            request: impl tonic::IntoRequest<super::ProvidePreimageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ProvidePreimageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/provide_preimage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "provide_preimage"));
            self.inner.unary(req, path, codec).await
        }
        /// Used to check if a user has provided the preimage for a HODL invoice in
        /// lightning receive flow.
        pub async fn query_preimage(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryPreimageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryPreimageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_preimage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "query_preimage"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_htlc(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryHtlcRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryHtlcResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_htlc",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "query_htlc"));
            self.inner.unary(req, path, codec).await
        }
        /// Resets the timelocks for a leaf's transactions. Can be used to reset the
        /// refund transaction timelock for a leaf (when the node transaction
        /// timelock is still > 300) or reset the node and refund transaction
        /// timelock. Returns an error if a leaf is not yet eligible to renew the
        /// timelocks, see RenewLeafRequest for more details.
        pub async fn renew_leaf(
            &mut self,
            request: impl tonic::IntoRequest<super::RenewLeafRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RenewLeafResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/renew_leaf",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "renew_leaf"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_signing_operator_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::GetSigningOperatorListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/get_signing_operator_list",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("spark.SparkService", "get_signing_operator_list"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_nodes(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryNodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryNodesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_nodes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "query_nodes"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_balance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "query_balance"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_user_signed_refunds(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryUserSignedRefundsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryUserSignedRefundsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_user_signed_refunds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("spark.SparkService", "query_user_signed_refunds"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_unused_deposit_addresses(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryUnusedDepositAddressesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryUnusedDepositAddressesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_unused_deposit_addresses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "spark.SparkService",
                        "query_unused_deposit_addresses",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_static_deposit_addresses(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryStaticDepositAddressesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryStaticDepositAddressesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_static_deposit_addresses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "spark.SparkService",
                        "query_static_deposit_addresses",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn subscribe_to_events(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeToEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SubscribeToEventsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/subscribe_to_events",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "subscribe_to_events"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Signs the provided refund transaction which spends the UTXO from a static
        /// deposit address. If successful, the UTXO will no longer be available to
        /// claim on the Spark network, and the refund transaction must be broadcasted
        /// on L1 to claim the funds. Returns an error if the UTXO has already been
        /// claimed.
        pub async fn initiate_static_deposit_utxo_refund(
            &mut self,
            request: impl tonic::IntoRequest<
                super::InitiateStaticDepositUtxoRefundRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InitiateStaticDepositUtxoRefundResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/initiate_static_deposit_utxo_refund",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "spark.SparkService",
                        "initiate_static_deposit_utxo_refund",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn exit_single_node_trees(
            &mut self,
            request: impl tonic::IntoRequest<super::ExitSingleNodeTreesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExitSingleNodeTreesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/exit_single_node_trees",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "exit_single_node_trees"));
            self.inner.unary(req, path, codec).await
        }
        /// The following endpoints enforce inclusion of Direct Transactions used
        /// for unilateral exits
        pub async fn cooperative_exit_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::CooperativeExitRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CooperativeExitResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/cooperative_exit_v2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "cooperative_exit_v2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn claim_transfer_sign_refunds_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::ClaimTransferSignRefundsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ClaimTransferSignRefundsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/claim_transfer_sign_refunds_v2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "spark.SparkService",
                        "claim_transfer_sign_refunds_v2",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn finalize_node_signatures_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::FinalizeNodeSignaturesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FinalizeNodeSignaturesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/finalize_node_signatures_v2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("spark.SparkService", "finalize_node_signatures_v2"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn initiate_preimage_swap_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::InitiatePreimageSwapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InitiatePreimageSwapResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/initiate_preimage_swap_v2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("spark.SparkService", "initiate_preimage_swap_v2"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn initiate_preimage_swap_v3(
            &mut self,
            request: impl tonic::IntoRequest<super::InitiatePreimageSwapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InitiatePreimageSwapResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/initiate_preimage_swap_v3",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("spark.SparkService", "initiate_preimage_swap_v3"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_leaf_swap_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::StartTransferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartTransferResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/start_leaf_swap_v2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "start_leaf_swap_v2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_transfer_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::StartTransferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartTransferResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/start_transfer_v2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "start_transfer_v2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_utxos_for_address(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUtxosForAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUtxosForAddressResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/get_utxos_for_address",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "get_utxos_for_address"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_spark_invoices(
            &mut self,
            request: impl tonic::IntoRequest<super::QuerySparkInvoicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySparkInvoicesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_spark_invoices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "query_spark_invoices"));
            self.inner.unary(req, path, codec).await
        }
        /// Inititiates a primary transfer in a Swap V3 protocol. The sender submits
        /// the transfer package, but the SOs will not tweak the keys at this stage of
        /// the flow. It will be done later, when the SSP initiates a counter swap.
        pub async fn initiate_swap_primary_transfer(
            &mut self,
            request: impl tonic::IntoRequest<super::InitiateSwapPrimaryTransferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InitiateSwapPrimaryTransferResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/initiate_swap_primary_transfer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "spark.SparkService",
                        "initiate_swap_primary_transfer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_wallet_setting(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateWalletSettingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWalletSettingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/update_wallet_setting",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "update_wallet_setting"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_wallet_setting(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryWalletSettingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryWalletSettingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/spark.SparkService/query_wallet_setting",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("spark.SparkService", "query_wallet_setting"));
            self.inner.unary(req, path, codec).await
        }
    }
}
