# Transfer (Send) Implementation Plan

This document plans the **send transfer** feature for the CANS SDK. It is based on the Breez Spark SDK reference implementation, our existing claim flow, Spark proto definitions, and the current transfer stub.

---

## 1. Protocol understanding (resolved from Breez SDK)

### 1.1 Two-phase key rotation model

A Spark transfer is a **two-phase key rotation**. There is no single tweak from sender to receiver. Instead, an **ephemeral intermediate key** bridges the two phases:

| Phase | Who | Operation | Key tweak sent to operators |
|-------|-----|-----------|-----------------------------|
| **Phase 1: Send** | Sender | Rotates leaf from `current_key` → `ephemeral_key` | `current_key - ephemeral_key` |
| **Phase 2: Claim** | Receiver | Rotates leaf from `ephemeral_key` → `derived_key` | `ephemeral_key - derived_key` |

The ephemeral key is randomly generated by the **sender** for each leaf. It never belongs to either party permanently — it is a cryptographic bridge.

### 1.2 What goes into `secret_cipher`

**`secret_cipher` = ECIES(receiver_identity_pk, ephemeral_private_key)**

The sender:
1. Generates a random `ephemeral_key` per leaf.
2. ECIES-encrypts the `ephemeral_key` to the receiver's identity public key.
3. Puts the ciphertext in `SendLeafKeyTweak.secret_cipher`.

The receiver:
1. ECIES-decrypts `secret_cipher` → recovers `ephemeral_key`.
2. Derives their own `derived_key` for the leaf.
3. Computes `tweak = ephemeral_key - derived_key`.
4. VSS-splits the tweak and sends shares to operators.

This is **consistent with our claim code**: `verify_and_decrypt_transfer` decrypts `secret_cipher` → `decrypted_signing_key` (this is the ephemeral key), then `prepare_and_apply_key_tweaks` computes `tweak = decrypted_signing_key - new_sk`. The naming just made it look like it was the "current" key — but it is actually the ephemeral key from the send side.

### 1.3 Sender's key material

The sender has the **full leaf signing key**, not just a share. In Spark's model, the owner has a full private key and the operators collectively hold a separate group key. Together they form the FROST threshold group (the user's single key is "role 1" in the nested FROST scheme). So `derive_signing_keypair(leaf_id)` gives the sender their full key — this is sufficient to:
- Compute `tweak = current_key - ephemeral_key` and VSS-split it.
- FROST-sign refund transactions (the user produces their signature share, operators produce theirs).

### 1.4 Refund transaction output key

**Refund transactions on the send side pay to the ephemeral public key** (the pubkey corresponding to `ephemeral_key`). Since the sender generates the ephemeral keypair, they know both the private and public parts. No invoice or receiver-provided per-leaf keys are needed for the refund output.

The receiver later replaces these refund transactions with new ones paying to their `derived_key`, which is the standard claim flow we already have.

### 1.5 Concurrency and retry

Breez uses a `with_leafs_spent_retry!` macro to handle cases where selected leaves become spent between selection and transfer initiation (e.g., due to a concurrent claim). Our SDK should similarly handle this — likely by catching a specific error from `start_transfer_v2` and re-selecting leaves.

---

## 2. Current state

### 2.1 Claim flow (working)

Our claim implementation (`crates/sdk/src/operations/claim.rs`) is complete and working:

1. Query pending transfers → `query_pending_transfers`.
2. Verify sender ECDSA over `SHA256(leaf_id || transfer_id || secret_cipher)`.
3. ECIES-decrypt `secret_cipher` → `decrypted_signing_key` (the ephemeral key from the sender).
4. Compute `tweak = decrypted_signing_key - new_sk` (receiver's derived key).
5. VSS-split tweak, send `ClaimTransferTweakKeys` to all operators.
6. Build new refund txs (CPFP, direct, direct-from-CPFP) paying to receiver's `new_xonly`.
7. Generate FROST nonces with tweaked key, send `ClaimTransferSignRefunds`.
8. Aggregate FROST signatures, send `FinalizeNodeSignatures`.
9. Insert claimed leaves into tree store.

### 2.2 Send stub (incomplete)

The current `crates/sdk/src/operations/transfer.rs` is a skeleton. It:

- Selects and reserves leaves — correct.
- VSS-splits the **sender's key directly** (wrong — should split `current - ephemeral` tweak).
- ECIES-encrypts **shares to operators** (wrong — should encrypt tweaked `SendLeafTweaks` per operator, plus `secret_cipher` to receiver).
- Calls `get_signing_commitments` but ignores the response.
- Sends an empty `StartTransferRequest` (no `TransferPackage`).
- Does not build refund txs, does not sign anything real.

---

## 3. What is missing (gap list)

### 3.1 Ephemeral key generation

For each leaf being sent, generate a random ephemeral keypair. This requires `WalletSigner` to support random secret generation (or we use `rand` + `secp256k1` directly).

**Difficulty**: Low. We already use `rand::thread_rng()`.

### 3.2 Send-side key tweak computation

For each leaf:
```
tweak = signer.subtract_secret_keys(&current_leaf_key, &ephemeral_key)
```

Then VSS-split the tweak and build `SendLeafKeyTweak` per operator (with `secret_share_tweak` + `pubkey_shares_tweak`).

**Difficulty**: Low. Identical math to claim but with different inputs. All primitives exist.

### 3.3 `secret_cipher` construction

```
secret_cipher = signer.ecies_encrypt(&receiver_identity_pubkey, &ephemeral_secret_key_bytes)
```

Plus ECDSA signature over `SHA256(leaf_id || transfer_id || secret_cipher)` using the sender's identity key.

**Difficulty**: Low. `ecies_encrypt` and `sign_ecdsa_message` exist on `WalletSigner`.

### 3.4 Refund transaction construction (sender side)

Build three refund tx variants per leaf, paying to the **ephemeral public key** (not the receiver's derived key):

| Refund type | Input | Sequence source |
|-------------|-------|-----------------|
| CPFP refund | `node_tx:vout` | From leaf's existing `refund_tx` sequence |
| Direct-from-CPFP refund | `node_tx:vout` | From leaf's existing `direct_from_cpfp_refund_tx` sequence |
| Direct refund | `direct_tx:0` | From leaf's existing `direct_refund_tx` sequence |

The output key for all three is `compressed_to_xonly(&ephemeral_pubkey)`.

**Difficulty**: Medium. Refund tx construction functions (`create_cpfp_refund_tx`, `create_direct_refund_tx`) already exist in `bitcoin_tx.rs`. However, the SDK's `TreeNode` currently lacks the `direct_tx`, `direct_refund_tx`, and `direct_from_cpfp_refund_tx` fields needed to extract sequences. **See 3.8.**

### 3.5 FROST signing of refund txs (sender side)

The sender must FROST-sign each refund tx with their **current** key (not the tweaked key — that's the claim side). Steps:

1. Call `get_signing_commitments` with `node_ids` and `count = 3` (CPFP + direct + direct-from-CPFP).
2. Map commitments to leaves and paths.
3. For each refund tx, compute `taproot_sighash` and produce user's FROST signature share using `sign_as_user`.
4. The signature shares go into `UserSignedTxSigningJob.user_signature`.

**Difficulty**: Medium. The FROST machinery exists in claim (nonce generation, `sign_as_user`, sighash). On the send side the key is the current (un-tweaked) key, which is simpler. The complexity is in correctly mapping the commitment response to each (leaf, path) tuple.

### 3.6 `TransferPackage` assembly

Build the proto message:

```
TransferPackage {
    leaves_to_send:               [UserSignedTxSigningJob for CPFP refunds],
    direct_leaves_to_send:        [UserSignedTxSigningJob for direct refunds],
    direct_from_cpfp_leaves_to_send: [UserSignedTxSigningJob for direct-from-CPFP refunds],
    key_tweak_package:            {operator_id -> ECIES(operator_pk, SendLeafTweaks)},
    user_signature:               ECDSA over hash of package,
    hash_variant:                 HASH_VARIANT_V2,
}
```

Where each `UserSignedTxSigningJob` contains:
- `leaf_id`, `signing_public_key` (sender's current), `raw_tx`, `signing_nonce_commitment`, `user_signature` (FROST sig), `signing_commitments` (operator's).

And each operator's `SendLeafTweaks` contains a list of `SendLeafKeyTweak` per leaf:
- `leaf_id`, `secret_share_tweak`, `pubkey_shares_tweak`, `secret_cipher`, `signature`.

**Difficulty**: High (many moving parts to wire together). All sub-pieces are addressed in 3.2–3.5.

### 3.7 `StartTransferRequest` finalization

```
StartTransferRequest {
    owner_identity_public_key:    sender_pk,
    receiver_identity_public_key: receiver_pk,
    transfer_package:             <assembled above>,
    expiry_time:                  now + TTL,
    spark_invoice:                optional,
}
```

Generate a `transfer_id` (UUID) if needed (or let the coordinator assign one — confirm which).

**Difficulty**: Low.

### 3.8 `TreeNode` data completeness

The SDK's `TreeNode` struct is missing fields that the send side needs:

| Missing field | Needed for |
|---------------|-----------|
| `direct_tx: Vec<u8>` | Direct refund tx input (spend the direct tx output) |
| `refund_tx` sequences | CPFP refund sequence (we have `refund_tx: Option<Vec<u8>>` — need to parse sequence from it) |
| `direct_refund_tx: Vec<u8>` | Extract direct refund sequence |
| `direct_from_cpfp_refund_tx: Vec<u8>` | Extract direct-from-CPFP refund sequence |

The proto `TreeNode` has all of these. The `proto_to_tree_node` converter and the `TreeStore` trait need to be extended.

**Difficulty**: Low-medium. Extend `TreeNode`, update converter, update `TreeStore` implementations, ensure sync populates these fields.

### 3.9 Reservation failure handling

If `start_transfer_v2` fails:
1. Cancel the leaf reservation (`cancel_reservation`).
2. Optionally call `CancelTransfer` on the coordinator if a `transfer_id` was assigned.
3. Retry with new leaves if the error is "leaves spent" (concurrent claim).

**Difficulty**: Low.

---

## 4. Send vs claim (corrected mirror view)

| Aspect | Send (sender) | Claim (receiver) |
|--------|---------------|------------------|
| **Input key** | `current_key` = `derive_signing_keypair(leaf_id)` | `ephemeral_key` = ECIES-decrypt `secret_cipher` |
| **Output key** | `ephemeral_key` (randomly generated) | `derived_key` = `derive_signing_keypair(leaf_id)` |
| **Tweak** | `current - ephemeral` | `ephemeral - derived` |
| **secret_cipher** | ECIES(receiver_pk, ephemeral_private) | Decrypts to ephemeral_private |
| **Tweak delivery** | Encrypted per-operator in `key_tweak_package` (inside `TransferPackage`) | Plaintext per-operator via `ClaimTransferTweakKeys` |
| **Refund output** | Pays to `ephemeral_pubkey` | Pays to `derived_pubkey` |
| **Refund signing key** | FROST with **current** key | FROST with **derived** key (tweaked) |
| **RPC** | `GetSigningCommitments` → build package → `StartTransferV2` | `ClaimTransferTweakKeys` → `ClaimTransferSignRefunds` → `FinalizeNodeSignatures` |
| **Coordinator model** | Single call, coordinator distributes | Per-operator tweak calls + coordinator for signing |

---

## 5. Recommended implementation order

### Step 1: Extend `TreeNode` (gap 3.8)

- Add `direct_tx`, `direct_refund_tx`, `direct_from_cpfp_refund_tx` to SDK `TreeNode`.
- Update `proto_to_tree_node` converter.
- Update `TreeStore` implementations (in-memory and any persistent stores).
- Unblocks: refund tx construction on send.

### Step 2: Ephemeral key + tweak + `secret_cipher` (gaps 3.1, 3.2, 3.3)

- Generate ephemeral keypair per leaf.
- Compute `tweak = current - ephemeral`, VSS-split.
- Build `SendLeafKeyTweak` list per operator with `secret_cipher` and ECDSA signature.
- ECIES-encrypt per operator → `key_tweak_package`.
- Unblocks: TransferPackage assembly.

### Step 3: Refund tx construction + FROST signing (gaps 3.4, 3.5)

- Build CPFP, direct, direct-from-CPFP refund txs paying to ephemeral pubkey.
- Call `get_signing_commitments`, map response to (leaf, path).
- FROST-sign each refund tx with current key.
- Build `UserSignedTxSigningJob` per (leaf, path).
- Unblocks: TransferPackage assembly.

### Step 4: `TransferPackage` + `StartTransferRequest` (gaps 3.6, 3.7)

- Assemble `TransferPackage` from steps 2 + 3.
- Sign the package (ECDSA user_signature).
- Build `StartTransferRequest` with `transfer_package`, `expiry_time`.
- Call `start_transfer_v2`.
- Finalize reservation (mark leaves as spent).

### Step 5: Error handling + retry (gap 3.9)

- Cancel reservation on failure.
- Handle "leaves spent" → re-select and retry.
- Cancel transfer on coordinator if needed.

### Step 6: E2E testing

- Integration test: send from wallet A → claim on wallet B.
- Verify: leaf balances, key rotation, refund tx validity.

---

## 6. Remaining open questions

Most of the critical unknowns from the previous version of this plan are now **resolved** by the Breez reference:

| Question | Status | Answer |
|----------|--------|--------|
| What is in `secret_cipher`? | **Resolved** | Ephemeral private key (ECIES to receiver) |
| How does sender compute tweak? | **Resolved** | `current - ephemeral` |
| How is receiver output key determined? | **Resolved** | Ephemeral public key (sender generates it) |
| Does sender have full key or share? | **Resolved** | Full key (role 1 in nested FROST) |
| Are two tweaks applied (send + claim)? | **Resolved** | Yes, sequential: sender tweak then receiver tweak |

**Still open:**

1. **`transfer_id` generation**: Does the client generate a UUID, or does the coordinator assign it on `StartTransferV2`? Breez seems to let the coordinator assign it. If client-generated, we need to produce it before signing `SHA256(leaf_id || transfer_id || secret_cipher)`.
2. **`hash_variant`**: Confirm `HASH_VARIANT_V2` is correct for the `user_signature` over the TransferPackage.
3. **Legacy vs TransferPackage path**: Should we support the old `LeafRefundTxSigningJob` path, or only `TransferPackage`? Recommend TransferPackage only.
4. **`WalletSigner` extensions needed**: Do we need a `generate_random_secret() -> SecretKey` method, or can we generate ephemeral keys with `rand` + `secp256k1` directly? The latter avoids a signer trait change.
5. **Commitment ordering**: The `GetSigningCommitmentsResponse` returns commitments per `(node_id, index)`. Need to confirm the index mapping: 0 = CPFP, 1 = direct, 2 = direct-from-CPFP? Or different ordering?

---

## 7. External references

- **Breez Spark SDK** (`https://github.com/breez/spark-sdk/`):
  - `crates/spark/src/services/transfer.rs` — `transfer_leaves_to`, `prepare_send_transfer_key_tweaks`, `prepare_transfer_package`, `sign_refunds`.
  - `crates/spark/src/utils/leaf_key_tweak.rs` — `prepare_leaf_key_tweaks_to_send` (ephemeral key generation).
  - `crates/spark/src/signer/mod.rs` — `Signer` trait (`subtract_secrets`, `encrypt_secret_for_receiver`, `split_secret_with_proofs`, `sign_frost`, `aggregate_frost`).
- **Our proto definitions**: `crates/transport/proto/spark.proto` — `StartTransferRequest`, `TransferPackage`, `UserSignedTxSigningJob`, `SendLeafKeyTweak`.
- **Our claim implementation**: `crates/sdk/src/operations/claim.rs` — confirms the receiver's side of the two-phase protocol.
